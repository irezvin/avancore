*** Тест-кейсы для форм
**** Варианты: 
(в форме должны быть tab'ы, группа с placeholder'ами, listOrder, creationOrderm)
***** Форма с моделью
***** Несколько моделей и свойства без модели
***** Псевдо-repeater
***** Форма без модели
**** В каждом кейсе
***** поведение с submitted и без
***** изменение модели, последующий опрос формы должен отражать её состояние
***** различный порядок bind, check
***** разные способы назначения свойств: updateModel, bind(getValue())
**** Проверка результатов (пока без javascript)
***** объект в контейнере
***** порядок объектов
***** реакция на submit

*** Новая спецификация формы (т.к. нам надо писать тест-кейсы в соответствии с чем-то)

    Сейчас по факту элемент управления (здесь: элемент) может находиться в двух режимах: с подключенной моделью и без подключенной модели.
    Как быть?
    Сделать
    1) вводимое значение 
    2) внутреннее значение
       a) если есть модель, это значение модели
       b) если нет модели, это значение по умолчанию (default)
    3) текущее значение = или вводимое, или внутреннее
    4) метод updateModel() обновляет внутреннее значение из текущего

    Всё равно непонятно.

    Жизненный цикл элемента:
    - создание
    - установка внутреннего состояния
    - если был предоставлен ввод, обновление внутреннего состояния
    - вывод

    Элементы бывают а) с моделью, б) без модели, при этом семантика свойств получается очень разная.
    Это получается из-за попыток совместить элемент с поставщиком данных.

    *Вариант А*: элемент совмещен с поставщиком данных.

    При этом мы будем оставаться во многом совместимыми со старой версией.
    
    | Свойство, метод             | Смысл                    | С моделью                               | Без модели                         |
    |-----------------------------+--------------------------+-----------------------------------------+------------------------------------|
    | getValue()                  | Возвр. "текущее" зн.     | canUseInput()? ввод : модель            | canUseInput()?  ввод : default     |
    | setValue($value)            | > "текущее" зн.          | ввод := $value                          | ввод := $value                     |
    | setDefault($default)        | > "внутреннее" зн.       | модель := $default                      | default := $default                |
    | getDefault()                | < "внутреннее" зн.       | модель                                  | default                            |
    | hasDefault()                | Есть внутр. зн.?         | true (убрать!)                          | true (убрать!)                     |
    | getInputValue()             | < ввод                   |                                         |                                    |
    | setInputValue()             | > ввод                   |                                         |                                    |
    | getHasInput()               | < ввод?                  |                                         |                                    |
    | setHasInput(bool $hasInput) | > ввод?                  |                                         |                                    |
    | isInputValid()              | Проверка ввода           |                                         |                                    |
    | canUseInput()               | Можно использовать ввод? | hasInput() && isInputValid()            | hasInput() && isInputValid()       |
    | updateModel()               | Уст. "текущее" зн.       | модель := ввод?? ввод: модель           | default := ввод?? default : модель |
    | updateFromModel()           | Уст. зн. в модель        | ввод ? := false                         | ввод ? := false                    |
    | getInputErrors()            | Ошибки проверки ввода    |                                         |                                    |
    | getModelErrors()            | Ошибки модели            | model->checked? model->getErrors() : [] | []                                 |
    | getErrors()                 | Ошибки                   | getInputErrors() + getModelErrors()     | getInputErrors()                   | 
    
    Недостаток этого подхода в "двойном смысле" свойства $default, название которого также нас несколько путает,
    а безобидная операция setDefault приведет к обновлению модели, что не очевидно для разработчика (не следует из названия).
        /Улучшить ситуацию можно, переименовав setDefault в, например, setInternalValue() и т.п./

    Кроме того, если в прототипе поставить сначала $model, потом $default, модель обновится!
        /это тоже решаемо/

    *РЕШЕНИЕ А1*, максимально близко подойдя к варианту, который есть сейчас (что ПЛЮС):
    - у элемента с моделью может быть $default
    - это значение используется при updateModel(), если не было ввода - что крайне тупо! - и нам надо возвращаться к hasDefault()
    - updateModel() теперь имеет тройную логику: model := input? input : (hasDefault? default : model)

    *РЕШЕНИЕ А2*, полностью игнорировать default при работе с моделью, при этом добавить методы get/setModelValue(), что совсем усложнит интерфейс.
  
    *Вариант Б*: поставщик данных является агрегатом элемента
        
*** Кешируемые члены в Ac_Model_Form*
**** Ac_Model_Form_Control
***** $_model - getModel(), setModel()
      Получает модель у $this->_parent, но только ОДИН раз. Если потом модель
      у предка поменяется, то у потомков она уже не обновится.
      Решение:
      a. *всегда вычислять* сл=1
      b. предок оповещает потомков о том, что модель изменилась сл=2
	 a. напрямую сл=2
	 b. потомки являются observer'ами сл=6, возможная задача - переход к observer'ам
***** $_hasOwnModel
      Означает, что у данного элемента своя ссылка на модель (а не полученная от предка).
***** $_presentation - строчное представение формы
      Генерируется методом fetchPresentation() и затем кешируется. Никак не чистится, т.е.
      мы должны передавать параметр $refresh=true.+
***** $_presentationWithWrapper
      Аналогично предыдущему, только при условии, что вокруг строчного представления еще
      обязательно есть wrapper.
***** $_value
      Хранит *значение* элемента управления.
      Устанавливается getValue().
      При этом оно берется
      a. из запроса, либо
      b. "по умолчанию"
	 a. из модели, если она есть
	 b. из default, если модели нет
      Логика очень WTFная, при этом разные элементы устанавливают логику по-разному.
***** $_gotValue
      Хранит true, если значение $this->_value имеет смысл (было обновлено или из
      внутреннего состояния, или из запроса)
***** $_default
      Значение, хранящееся во "внутреннем состоянии" элемента управления (или установленное
      в свойствах, или полученное из модели).
***** $_hasDefault
      Означает, что во "внутреннем состоянии" хранится какое-либо значение и $this->_default
      имеет смысл.
***** $_property
      Хранит метаданные о свойстве модели.
      Заполняется один раз, getModelProperty(). Что несколько WTFно.
***** $_submitted
      Была ли отправлена пользователем форма или нет.
      Вычисляется один раз в isSubmitted().
***** $_creationOrder - понятно, как используется, но не понятно, как устанавливается
