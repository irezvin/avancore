* Multi-class implementation levels & extras
** *Level1* Model inheritance using common base
*** requires
    - nothing
*** allows
    - to create several different solutions (applications) with common code base
*** concept
   - concrete solution' classes (model, mapper, maybe App) are inherited from basic classes
   - additional relations are defined in concrete classes
   - maybe additional fields are defined in concrete classes
** *Level2* Model inheritance using several-mappers-per-table
*** requires
**** Mapper Restrictions 
     - mapper must add WHERE restrictions and, probably, some constants to all statements that it issues
     - it may be implemented on persistence level (since record can't change the mappers on-the-fly)
*** provides
    - simple hierarchy with a common table
    - way for 'cleaner' separation with *MTR*
** *Level3* types concept
   - mapper can be responsible for several types of records
   - metadata and prototype are stored per-type
   - SqlSelect is created for a type (or for several types)
   - all operations require a type
   - probably $mapper->getType('foo') returns mapper-compatible interface
   - types can be enumerated *dynamically*
   - a PHP class may be optionally assigned to a type
** *Level3.1* inheritance of types
** *Level3.2* multiple inheritance of types
** *Level3.3* mixed-type sets
** Extras
*** *MTR*: Multi-Table Records 
**** requires
**** provides 
     - comfort within all levels
     - extend tables in more clever and database-centric way
**** implementation
     - on persistence level
     - in Sql_Select: additional alias is given for additional table
*** Column restrictions in Cg
**** provides
     - ???
*** Solution inheritance support in Cg

* Thoughts on multi-table
  - Static
    - model object has plain fields defined in a class
    - there are 2 extra objects: mapper persistence mixin (statically integrated) + relation
  - Dynamic
    - additional fields and relations are defined as per-model mix-in
    - class Ac_Model_DataMixin (properties, associations) - 1 instance per object
  - Approach
    - a: extra->model (good for static linking, i.e. to model sub-classes)
    - b: model->extra (may be used to share mixins) <- it *is* important to ensure no extension
    - records are shared
  - *Ac_Model_Mapper_Mixin_ExtraTable*
    - relationId
  - Cg support
    - Ac_Cg_Model_Part
      - string ownerModelId <- optional; if not provided, modelMixinClass & mapperMixinClass are required
      - string ownerModelClass <- optional; if there is no owner model, can be used to restrict/type hint
	classes of possible mixables
      - string ownerRelationId (tries to guess)
      - bool ownerRelationIncoming (tries to guess)
      - modelMixinClass - if set, the model part is defined as a mix-in (the mapper part is always defined as a mix-in)
      - mapperMixinClass - false | string | true(guess) - if set, mapper mixin is defined as a class
	- nonStatic - if true, the persistence aggregate is NOT statically added to the mapper (is always true if
	  owner model is not provided)

* Thoughts on types support

** Interface
   - Mapper acts if there is no types at all
     - selects return all records
     - Ac_Sql_Select has no special restrictions
     - list/get Relations returns only common relations
     - record instances are of their respective classes/types
     - createRecord() creates record of $this->defaultType (if any) or triggers an error
     - getRecordPrototype() returns prototype of $this->defaultType or triggers an error
   - Ac_Model_Mapper
     - array listTypes()
     - Ac_Model_Mapper_Type getType($id or $record, $dontThrow = false) 
     - string getTypeId($record)
     - string determineTypeId($row)
   - Ac_Model_Mapper_Type implements Ac_I_Model_Mapper
     - implements all methods of record access as Ac_Model_Mapper
     - implements getInfoParams() (what a crappy name)
     - implements getSqlSelectPrototype()
     - listTypes()/getType() will return sub-types
     - may be abstract ($isAbstract) - applies to Mappers too
*** Decisions
     - [ ] does Ac_Model_Mapper act as a base type for descendant Types?
     - [ ] are the Types Mappers too?
       - [ ] if they are, does the record reference the Type instead of base Mapper?
	 - Ac_Model_Mapper'id has the Parent/Child form (i.e. Foo_Product/Teapot)
** Implementation/internals
   - *Ac_Model_Mapper_Persistence* - injected aggregate - impements persistence methods
     - Ac_Model_Mapper_Persistence_MultiTable - implements multi-table records;
       is called on loading, saving, deleting
   - *Ac_Model_Mapper_Type_Provider* - injected aggregate - enumerates, returns types; 
     modifies Sql statements to add necessary info to select queries; determines row classes.
   - *Ac_Model_Object* 
     - +getMapperTypeId()+
     - +Ac_Model_Mapper_Type getMapperType()+
   - *Ac_Model_Relation*
     - if src/dest mapper set, only records with $mapper->isMyRecord($record) are considered
       (since with introduction of heterogeneous record sets there may be only partial
        support of concrete Relation by set items)
    
