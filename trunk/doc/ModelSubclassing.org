* Multi-class implementation levels & extras
** *Level1* Model inheritance using common base
*** requires
    - nothing
*** allows
    - to create several different solutions (applications) with common code base
*** concept
   - concrete solution' classes (model, mapper, maybe App) are inherited from basic classes
   - additional relations are defined in concrete classes
   - maybe additional fields are defined in concrete classes
** *Level2* Model inheritance using several-mappers-per-table
*** requires
**** Mapper Restrictions 
     - mapper must add WHERE restrictions and, probably, some constants to all statements that it issues
     - it may be implemented on persistence level (since record can't change the mappers on-the-fly)
*** provides
    - simple hierarchy with a common table
    - way for 'cleaner' separation with *MTR*
** *Level3* types concept
   - mapper can be responsible for several types of records
   - metadata and prototype are stored per-type
   - SqlSelect is created for a type (or for several types)
   - all operations require a type
   - probably $mapper->getType('foo') returns mapper-compatible interface
   - types can be enumerated *dynamically*
   - a PHP class may be optionally assigned to a type
** *Level3.1* inheritance of types
** *Level3.2* multiple inheritance of types
** *Level3.3* mixed-type sets
** Extras
*** *MTR*: Multi-Table Records 
**** requires
**** provides 
     - comfort within all levels
     - extend tables in more clever and database-centric way
**** implementation
     - on persistence level
     - in Sql_Select: additional alias is given for additional table
*** Column restrictions in Cg
**** provides
     - ???
*** Solution inheritance support in Cg

* Thoughts on multi-table
  - Static
    - model object has plain fields defined in a class
    - there are 2 extra objects: mapper persistence mixin (statically integrated) + relation
  - Dynamic
    - additional fields and relations are defined as per-model mix-in
    - class Ac_Model_DataMixin (properties, associations) - 1 instance per object
  - Approach
    - a: extra->model (good for static linking, i.e. to model sub-classes)
    - b: model->extra (may be used to share mixins) <- it *is* important to ensure no extension
    - records are shared
  - *Ac_Model_Mapper_Mixin_ExtraTable*
    - relationId
  - Cg support
    - Ac_Cg_Model_Part
      - string ownerModelId <- optional; if not provided, modelMixinClass & mapperMixinClass are required
      - string ownerModelClass <- optional; if there is no owner model, can be used to restrict/type hint
	classes of possible mixables
      - string ownerRelationId (tries to guess)
      - bool ownerRelationIncoming (tries to guess)
      - modelMixinClass - if set, the model part is defined as a mix-in (the mapper part is always defined as a mix-in)
      - mapperMixinClass - false | string | true(guess) - if set, mapper mixin is defined as a class
	- nonStatic - if true, the persistence aggregate is NOT statically added to the mapper (is always true if
	  owner model is not provided)

* Thoughts on types support

** Interface
   - Mapper acts if there is no types at all
     - selects return all records
     - Ac_Sql_Select has no special restrictions
     - list/get Relations returns only common relations
     - record instances are of their respective classes/types
     - createRecord() creates record of $this->defaultType (if any) or triggers an error
     - getRecordPrototype() returns prototype of $this->defaultType or triggers an error
   - Ac_Model_Mapper
     - array listTypes()
     - Ac_Model_Mapper_Type getType($id or $record, $dontThrow = false) 
     - string getTypeId($record)
     - string determineTypeId($row)
   - Ac_Model_Mapper_Type implements Ac_I_Model_Mapper
     - implements all methods of record access as Ac_Model_Mapper
     - implements getInfoParams() (what a crappy name)
     - implements getSqlSelectPrototype()
     - listTypes()/getType() will return sub-types
     - may be abstract ($isAbstract) - applies to Mappers too
*** Decisions
     - [ ] does Ac_Model_Mapper act as a base type for descendant Types?
     - [ ] are the Types Mappers too?
       - [ ] if they are, does the record reference the Type instead of base Mapper?
	 - Ac_Model_Mapper'id has the Parent/Child form (i.e. Foo_Product/Teapot)
** Implementation/internals
   - *Ac_Model_Mapper_Persistence* - injected aggregate - impements persistence methods
     - Ac_Model_Mapper_Persistence_MultiTable - implements multi-table records;
       is called on loading, saving, deleting
   - *Ac_Model_Mapper_Type_Provider* - injected aggregate - enumerates, returns types; 
     modifies Sql statements to add necessary info to select queries; determines row classes.
   - *Ac_Model_Object* 
     - +getMapperTypeId()+
     - +Ac_Model_Mapper_Type getMapperType()+
   - *Ac_Model_Relation*
     - if src/dest mapper set, only records with $mapper->isMyRecord($record) are considered
       (since with introduction of heterogeneous record sets there may be only partial
        support of concrete Relation by set items)
    
* TODO Multi-table ("ExtraTable")
  - [-] draft implementation
    - [-] features
      - [X] extra is referenced => false
      - [X] loading of many records
      - [ ] create Ac_Model_Sql_TableProvider to access the fields of extra table
      - [X] ability to re-map field names +(also add default re-mapping suffix)+
	- +requires support of fields re-mapping by Ac_Model_Mapper+
      - [ ] ability to load-by-join
	- [ ] Ac_Model_Mapper::$extraColumns, $extraJoins, $extraWhere - are always applied
	  - [ ] must be reflected in Ac_Sql_Select prototoype when it's based on mapper
	  - [ ] ??how does it play with Ac_Sql_Select_TableProvider??
      - [ ] Cg support
	- [ ] option A: add extra fields into model object <- at the moment won't be implemented 
             (but might be useful in the future with direct inheritance)
	- [ ] option B: create mixable base class and register it as mixable
	- [ ] +option C: don't create additional mixable base class, but register ++
	      +it as a part of model' mapper (using Ac_Model_Mapper_Mixable_ExtraTable)+
	      won't work since we need model mixable class
    - [X] without model mixable
    - [X] with model mixable
      - [X] Ac_Model_Mixable_Data
	- [X] can have properties and methods
	- [X] check, bind
	- [X] test
	  - [X] test smart event assignment
	  - [X] test simple variant
      - [X] Ac_Model_Mixable_Object
	- [X] can have referenced, referencing, NN records
      - [X] Usable mixable associations that declare list/get/create methods
    - [ ] Ac_Model_Relation $fieldMapping
    - [ ] Ac_Model_Mapper $fieldMapping (modelFieldName => array(alias, field name or Sql expression)
    - [ ] Ac_Model_Mixable_ExtraTable should extend host 
          mapper's unique indices and nullable columns
    - [ ] Ac_Model_Mixable_ExtraTable should create its' own Ac_Sql_Select_TableProvider
          with additional table
  - [-] codegen support
    - [-] Ac_Cg_Model_Part extends Ac_Cg_Model
      - [-] masterRelations: IDs of relations to "masters"
	- [X] master relations must be 1-1
	- [X] either all-incoming or one-outgoing model, mixing not possible
	- [X] Base model class is Ac_Model_Mixable_Object
	- [ ] Ac_Model_Mixable_ExtraTable is created
	- [ ] ImplMapper is created too
	- [ ] Ac_Model_Mixable_ExtraTable must provide relations from ImplMapper 
              with corresponding $srcExtraJoins / $destExtraJoins 
              and $fieldMapping, $fieldMapping2
